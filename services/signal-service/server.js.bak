const express = require('express');
const amqp = require('amqplib');
const { v4: uuidv4 } = require('uuid');

// 创建 Express 应用
const app = express();
const PORT = process.env.PORT || 3002;

// 中间件
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 信号存储
const signals = new Map();

// RabbitMQ 配置
const RABBITMQ_HOST = process.env.RABBITMQ_HOST || 'rabbitmq';
const RABBITMQ_PORT = process.env.RABBITMQ_PORT || '5672';
const RABBITMQ_USER = process.env.RABBITMQ_USER || 'liqpro';
const RABBITMQ_PASS = process.env.RABBITMQ_PASS || 'liqpro';

// 队列名称
const POOL_DATA_QUEUE = 'pool_data_queue';
const SIGNAL_QUEUE = 'signal_queue';

// 连接 URL
const connectionURL = `amqp://${RABBITMQ_USER}:${RABBITMQ_PASS}@${RABBITMQ_HOST}:${RABBITMQ_PORT}`;

// 连接和通道
let connection = null;
let channel = null;

// 工具函数
function calculateStandardDeviation(values) {
  const avg = calculateAverage(values);
  const squareDiffs = values.map(value => Math.pow(value - avg, 2));
  const avgSquareDiff = calculateAverage(squareDiffs);
  return Math.sqrt(avgSquareDiff);
}

function calculateAverage(values) {
  return values.reduce((sum, value) => sum + value, 0) / values.length;
}

function calculateCoefficientOfVariation(values) {
  const avg = calculateAverage(values);
  if (avg === 0) return 0;
  const stdDev = calculateStandardDeviation(values);
  return stdDev / avg;
}

function calculateDailyChangeRate(values) {
  if (values.length < 2) return 0;
  
  let totalChangeRate = 0;
  for (let i = 1; i < values.length; i++) {
    const prevValue = values[i-1];
    if (prevValue === 0) continue;
    
    const changeRate = Math.abs((values[i] - prevValue) / prevValue);
    totalChangeRate += changeRate;
  }
  
  return totalChangeRate / (values.length - 1);
}

function mapToScore(value, minValue, maxValue, minScore, maxScore) {
  if (value <= minValue) return minScore;
  if (value >= maxValue) return maxScore;
  
  const valueRange = maxValue - minValue;
  const scoreRange = maxScore - minScore;
  
  return minScore + ((value - minValue) / valueRange) * scoreRange;
}

// 评分系统函数
function calculateBasePerformanceScore(pool) {
  // 交易量评分 (40%) - 调整为支持更高交易量
  const volumeScore = mapToScore(
    pool.volume24h || 0,
    100000,    // 提高最小有意义交易量到10万
    100000000, // 提高理想交易量到1亿
    0,         // 最低分
    100        // 最高分
  );
  
  // 24h收益率评分 (35%) - 保持现有阈值，因为收益率百分比不应随交易量变化
  const yieldScore = (pool.yield24h || 0) <= 0 
    ? 0 
    : mapToScore(
        pool.yield24h,
        0.0005, // 最小有意义收益率 (0.05%)
        0.005,  // 理想收益率 (0.5%)
        0,      // 最低分
        100     // 最高分
      );
  
  // 流动性评分 (20%) - 相应提高流动性要求
  const liquidityScore = mapToScore(
    pool.liquidity || 0,
    1000000,   // 提高最小有意义流动性到100万
    50000000,  // 提高理想流动性到5000万
    0,         // 最低分
    100        // 最高分
  );
  
  // 费用总量评分 (5%) - 相应提高费用阈值
  const feesScore = mapToScore(
    pool.fees24h || 0,
    1000,     // 提高最小有意义费用
    100000,   // 提高理想费用
    0,        // 最低分
    100       // 最高分
  );
  
  // 计算加权总分
  const weightedScore = 
    volumeScore * 0.4 +
    yieldScore * 0.35 +
    liquidityScore * 0.2 +
    feesScore * 0.05;
  
  return {
    volumeScore,
    yieldScore,
    liquidityScore,
    feesScore,
    finalScore: weightedScore
  };
}

function calculateStabilityScore(pool, historicalData) {
  // 如果没有历史数据，返回默认分数
  if (!historicalData || historicalData.length < 5) {
    return {
      priceVolatility: null,
      yieldStability: null,
      volumeConsistency: null,
      liquidityStability: null,
      stabilityScore: 60
    };
  }
  
  // 计算价格波动率 (40%)
  const priceVolatility = pool.priceChange24h ? Math.abs(pool.priceChange24h) : 0.05;
  const priceVolatilityScore = mapToScore(priceVolatility, 0.5, 0, 0, 100);
  
  // 计算收益稳定性 (30%)
  const yieldStabilityScore = pool.yield24h ? mapToScore(Math.abs(pool.yield24h), 0.05, 0, 100, 0) : 60;
  
  // 计算交易量一致性 (20%) - 调整交易量阈值
  const volumeConsistencyScore = pool.volume24h ? mapToScore(pool.volume24h, 100000, 100000000, 0, 100) : 60;
  
  // 计算流动性稳定性 (10%) - 调整流动性阈值
  const liquidityStabilityScore = pool.liquidity ? mapToScore(pool.liquidity, 1000000, 50000000, 0, 100) : 60;
  
  // 计算加权总分
  const stabilityScore = 
    priceVolatilityScore * 0.4 +
    yieldStabilityScore * 0.3 +
    volumeConsistencyScore * 0.2 +
    liquidityStabilityScore * 0.1;
  
  return {
    priceVolatility,
    yieldStability: pool.yield24h || 0,
    volumeConsistency: pool.volume24h || 0,
    liquidityStability: pool.liquidity || 0,
    stabilityScore
  };
}

function calculateRiskScore(pool) {
  // 价格风险 (40%)
  const priceRisk = pool.priceChange24h ? Math.abs(pool.priceChange24h) * 50 : 50;
  
  // 流动性风险 (30%) - 调整流动性阈值
  const liquidityRisk = pool.liquidity ? mapToScore(pool.liquidity, 1000000, 50000000, 100, 0) : 50;
  
  // 池子年龄风险 (30%) - 对于高交易量池子，可以稍微放宽年龄要求
  const ageRisk = pool.creationTime 
    ? mapToScore(
        (Date.now() - new Date(pool.creationTime).getTime()) / (1000 * 60 * 60 * 24),
        2,     // 降低最小天数要求
        10,    // 降低理想天数要求
        100,   // 新池子高风险
        30     // 老池子低风险
      )
    : 50;
  
  // 计算加权总风险分数
  const riskScore = 
    priceRisk * 0.4 +
    liquidityRisk * 0.3 +
    ageRisk * 0.3;
  
  return {
    priceRisk,
    liquidityRisk,
    ageRisk,
    riskScore
  };
}

/**
 * 设置 RabbitMQ 连接和通道
 */
const setupRabbitMQ = async () => {
  try {
    console.log('正在连接到 RabbitMQ...');
    console.log(`RabbitMQ 连接 URL: amqp://${RABBITMQ_USER}:***@${RABBITMQ_HOST}:${RABBITMQ_PORT}`);
    
    // 创建连接
    connection = await amqp.connect(connectionURL);
    console.log('RabbitMQ 连接成功');
    
    // 处理连接关闭
    connection.on('close', () => {
      console.warn('RabbitMQ 连接已关闭，尝试重新连接...');
      setTimeout(setupRabbitMQ, 5000);
    });
    
    // 创建通道
    channel = await connection.createChannel();
    console.log('RabbitMQ 通道创建成功');
    
    // 确保队列存在
    await channel.assertQueue(POOL_DATA_QUEUE, { durable: true });
    await channel.assertQueue(SIGNAL_QUEUE, { durable: true });
    console.log(`队列 ${POOL_DATA_QUEUE} 和 ${SIGNAL_QUEUE} 已确认`);
    
    // 设置消费者
    await setupConsumers();
    
    console.log('RabbitMQ 设置完成');
    return true;
  } catch (error) {
    console.error('RabbitMQ 设置失败:', error);
    return false;
  }
};

/**
 * 设置消息消费者
 */
const setupConsumers = async () => {
  if (!channel) {
    throw new Error('RabbitMQ 通道未初始化');
  }
  
  // 消费池数据队列
  channel.consume(POOL_DATA_QUEUE, async (msg) => {
    if (msg) {
      try {
        const content = msg.content.toString();
        console.log(`收到池数据消息: ${content.substring(0, 100)}...`);
        
        // 处理池数据
        await processPoolData(JSON.parse(content));
        
        // 确认消息
        channel.ack(msg);
      } catch (error) {
        console.error('处理池数据消息失败:', error);
        // 拒绝消息并重新排队
        channel.nack(msg, false, true);
      }
    }
  });
  
  console.log(`已设置 ${POOL_DATA_QUEUE} 队列的消费者`);
};

/**
 * 发布信号到队列
 */
const publishSignal = async (signal) => {
  if (!channel) {
    console.warn('RabbitMQ 通道未初始化，无法发布信号');
    return;
  }
  
  try {
    const message = JSON.stringify(signal);
    channel.publish('', SIGNAL_QUEUE, Buffer.from(message));
    console.log(`信号已发布到 ${SIGNAL_QUEUE} 队列`);
  } catch (error) {
    console.error('发布信号失败:', error);
  }
};

/**
 * 处理池数据并生成信号
 */
const processPoolData = async (poolData) => {
  try {
    // 使用address作为poolId的备选
    const poolId = poolData.poolId || poolData.address || 'unknown';
    console.log(`处理池数据: ${poolId}`);
    
    // 生成信号
    const generatedSignals = await generateSignalsFromPoolData(poolData);
    
    // 存储和发布信号
    for (const signal of generatedSignals) {
      const signalId = uuidv4();
      const timestamp = new Date().toISOString();
      
      const newSignal = {
        id: signalId,
        timestamp,
        poolId: signal.poolId || '',
        tokenA: signal.tokenA || '',
        tokenB: signal.tokenB || '',
        action: signal.action || 'HOLD',
        confidence: signal.confidence || 0,
        price: signal.price,
        reason: signal.reason,
        scores: signal.scores || {},
        recommendation: signal.recommendation || {},
        metadata: signal.metadata
      };
      
      // 存储信号
      signals.set(signalId, newSignal);
      
      // 发布信号到队列
      await publishSignal(newSignal);
      
      console.log(`信号已生成并发布: ${signalId}`);
    }
  } catch (error) {
    console.error('处理池数据失败:', error);
  }
};

/**
 * 从池数据生成信号
 */
const generateSignalsFromPoolData = async (poolData) => {
  try {
    const poolId = poolData.poolId || poolData.address || 'unknown';
    console.log(`从池数据生成信号: ${poolId}`);
    
    const generatedSignals = [];
    
    // 1. 计算基础性能评分
    const performanceScore = calculateBasePerformanceScore(poolData);
    console.log(`性能评分详情 [${poolId}]:`, {
      volumeScore: performanceScore.volumeScore,
      yieldScore: performanceScore.yieldScore,
      liquidityScore: performanceScore.liquidityScore,
      feesScore: performanceScore.feesScore,
      finalScore: performanceScore.finalScore,
      rawData: {
        volume24h: poolData.volume24h,
        yield24h: poolData.yield24h,
        liquidity: poolData.liquidity,
        fees24h: poolData.fees24h
      }
    });
    
    // 2. 计算稳定性评分
    const stabilityMetrics = calculateStabilityScore(poolData);
    console.log(`稳定性评分详情 [${poolId}]:`, {
      priceVolatility: stabilityMetrics.priceVolatility,
      yieldStability: stabilityMetrics.yieldStability,
      volumeConsistency: stabilityMetrics.volumeConsistency,
      liquidityStability: stabilityMetrics.liquidityStability,
      stabilityScore: stabilityMetrics.stabilityScore
    });
    
    // 3. 计算风险评分
    const riskMetrics = calculateRiskScore(poolData);
    console.log(`风险评分详情 [${poolId}]:`, {
      priceRisk: riskMetrics.priceRisk,
      liquidityRisk: riskMetrics.liquidityRisk,
      ageRisk: riskMetrics.ageRisk,
      riskScore: riskMetrics.riskScore
    });
    
    // 4. 计算最终评分
    const finalScore = (
      performanceScore.finalScore * 0.4 +
      stabilityMetrics.stabilityScore * 0.4 +
      (100 - riskMetrics.riskScore) * 0.2
    );
    
    console.log(`最终评分 [${poolId}]: ${finalScore.toFixed(2)}`, {
      performanceContribution: (performanceScore.finalScore * 0.4).toFixed(2),
      stabilityContribution: (stabilityMetrics.stabilityScore * 0.4).toFixed(2),
      riskContribution: ((100 - riskMetrics.riskScore) * 0.2).toFixed(2)
    });
    
    // 5. 生成信号（如果评分超过阈值）
    const SIGNAL_THRESHOLD = 60;  // 降低信号生成阈值
    
    if (finalScore >= SIGNAL_THRESHOLD) {
      // 确定信号类型和置信度
      let action = 'HOLD';
      let confidence = 0;
      let reason = '';
      
      const priceChange = poolData.priceChange24h || poolData.priceChange || 0;
      
      if (Math.abs(priceChange) > 0.05 && stabilityMetrics.stabilityScore > 60) {
        action = priceChange > 0 ? 'BUY' : 'SELL';
        confidence = Math.min(0.7 + (finalScore - SIGNAL_THRESHOLD) / 100, 1);
        reason = `${action === 'BUY' ? '上涨' : '下跌'}趋势明显，价格24小时变化${(Math.abs(priceChange) * 100).toFixed(2)}%，综合评分${finalScore.toFixed(1)}`;
      } else if (finalScore > 85) {
        action = 'BUY';
        confidence = 0.7;
        reason = `高质量池子，综合评分${finalScore.toFixed(1)}，预期收益稳定`;
      }
      
      if (action !== 'HOLD') {
        // 生成价格区间建议
        const priceRangePercentage = stabilityMetrics.priceVolatility > 0.1 ? 0.08 : 0.05;
        const currentPrice = poolData.price || 0;
        
        const signal = {
          poolId: poolId,
          tokenA: poolData.tokenA || poolData.tokenX || 'Unknown',
          tokenB: poolData.tokenB || poolData.tokenY || 'Unknown',
          action: action,
          confidence: confidence,
          price: currentPrice,
          reason: reason,
          scores: {
            performanceScore: performanceScore.finalScore,
            stabilityScore: stabilityMetrics.stabilityScore,
            riskScore: riskMetrics.riskScore,
            finalScore: finalScore
          },
          recommendation: {
            positionSize: finalScore > 85 ? 'high' : 'medium',
            priceRange: {
              min: currentPrice * (1 - priceRangePercentage),
              max: currentPrice * (1 + priceRangePercentage),
              current: currentPrice,
              optimalRangePercentage: priceRangePercentage * 100
            }
          },
          metadata: {
            volume24h: poolData.volume24h || poolData.volume || 0,
            liquidity: poolData.liquidity || 0,
            yield24h: poolData.yield24h || 0,
            stabilityMetrics: {
              priceVolatility: stabilityMetrics.priceVolatility,
              yieldStability: stabilityMetrics.yieldStability,
              volumeConsistency: stabilityMetrics.volumeConsistency,
              liquidityStability: stabilityMetrics.liquidityStability
            },
            riskMetrics: {
              priceRisk: riskMetrics.priceRisk,
              liquidityRisk: riskMetrics.liquidityRisk,
              ageRisk: riskMetrics.ageRisk
            }
          }
        };
        
        generatedSignals.push(signal);
        console.log(`生成信号: ${action} ${signal.tokenA}-${signal.tokenB} 置信度: ${confidence.toFixed(2)}`);
      }
    } else {
      console.log(`池子评分不足，不生成信号: ${poolId}, 评分: ${finalScore.toFixed(1)}`);
    }
    
    return generatedSignals;
  } catch (error) {
    console.error('生成信号失败:', error);
    return [];
  }
};

// 健康检查路由
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', service: 'signal-service' });
});

// API 路由
app.get('/api/signals', async (req, res) => {
  try {
    const allSignals = Array.from(signals.values());
    res.status(200).json(allSignals);
  } catch (error) {
    console.error('获取信号失败:', error);
    res.status(500).json({ error: '获取信号失败' });
  }
});

app.get('/api/signals/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const signal = signals.get(id);
    
    if (signal) {
      res.status(200).json(signal);
    } else {
      res.status(404).json({ error: '信号未找到' });
    }
  } catch (error) {
    console.error('获取特定信号失败:', error);
    res.status(500).json({ error: '获取特定信号失败' });
  }
});

// 添加一个测试路由，用于发布测试信号
app.post('/api/test/publish-signal', async (req, res) => {
  try {
    const testSignal = {
      id: uuidv4(),
      timestamp: new Date().toISOString(),
      poolId: 'test-pool',
      tokenA: 'SOL',
      tokenB: 'USDC',
      action: 'BUY',
      confidence: 0.8,
      price: 100.0,
      reason: '测试信号',
      metadata: {
        test: true
      }
    };
    
    // 存储信号
    signals.set(testSignal.id, testSignal);
    
    // 发布信号到队列
    if (channel) {
      await publishSignal(testSignal);
      res.status(200).json({ success: true, message: '测试信号已发布', signal: testSignal });
    } else {
      res.status(500).json({ success: false, message: 'RabbitMQ未连接，无法发布信号' });
    }
  } catch (error) {
    console.error('发布测试信号失败:', error);
    res.status(500).json({ error: '发布测试信号失败' });
  }
});

// 清理过期信号
const cleanupExpiredSignals = () => {
  const now = new Date();
  let cleanupCount = 0;
  
  signals.forEach((signal, id) => {
    const signalDate = new Date(signal.timestamp);
    const ageInHours = (now.getTime() - signalDate.getTime()) / (1000 * 60 * 60);
    
    // 删除超过24小时的信号
    if (ageInHours > 24) {
      signals.delete(id);
      cleanupCount++;
    }
  });
  
  if (cleanupCount > 0) {
    console.log(`已清理 ${cleanupCount} 个过期信号`);
  }
};

// 设置定期清理过期信号的间隔
const cleanupInterval = setInterval(cleanupExpiredSignals, 3600000); // 每小时清理一次

// 启动服务器
const startServer = async () => {
  try {
    console.log('信号服务启动中...');
    console.log(`环境变量: PORT=${PORT}, RABBITMQ_HOST=${RABBITMQ_HOST}, RABBITMQ_USER=${RABBITMQ_USER}`);
    
    // 设置 RabbitMQ
    const rabbitConnected = await setupRabbitMQ();
    if (!rabbitConnected) {
      console.warn('RabbitMQ 连接失败，但服务将继续运行');
    }
    
    // 启动 HTTP 服务器
    app.listen(PORT, () => {
      console.log(`信号服务运行在端口 ${PORT}`);
    });
    
    console.log('信号服务已启动');
  } catch (error) {
    console.error('服务器启动失败:', error);
    process.exit(1);
  }
};

// 处理进程终止信号
process.on('SIGINT', async () => {
  console.log('接收到 SIGINT 信号，正在关闭服务...');
  clearInterval(cleanupInterval);
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('接收到 SIGTERM 信号，正在关闭服务...');
  clearInterval(cleanupInterval);
  process.exit(0);
});

// 启动服务器
startServer(); 