const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const amqp = require('amqplib');
const { v4: uuidv4 } = require('uuid');
const mongoose = require('mongoose');

// 创建 Express 应用
const app = express();
const PORT = process.env.PORT || 3002;

// 中间件
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// 信号存储
const signals = new Map();

// RabbitMQ 配置
const RABBITMQ_HOST = process.env.RABBITMQ_HOST || 'rabbitmq';
const RABBITMQ_PORT = process.env.RABBITMQ_PORT || '5672';
const RABBITMQ_USER = process.env.RABBITMQ_USER || 'liqpro';
const RABBITMQ_PASS = process.env.RABBITMQ_PASS || 'liqpro';
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://mongodb:27017/liqpro';

// 队列名称
const POOL_DATA_QUEUE = 'pool_data_queue';
const SIGNAL_QUEUE = 'signal_queue';

// 连接 URL
const connectionURL = `amqp://${RABBITMQ_USER}:${RABBITMQ_PASS}@${RABBITMQ_HOST}:${RABBITMQ_PORT}`;

// 连接和通道
let connection = null;
let channel = null;

// 定义信号数据模型
const signalSchema = new mongoose.Schema({
  id: String,
  analysis_timestamp: Date,
  market_condition: {
    trend: String,
    volatility: String
  },
  t1_pools: [{
    pool_address: String,
    name: String,
    token_pair: {
      token_x: {
        symbol: String,
        address: String
      },
      token_y: {
        symbol: String,
        address: String
      }
    },
    metrics: {
      liquidity: Number,
      volume_24h: Number,
      fees_24h: Number,
      daily_yield: Number,
      active_bin: {
        binId: Number,
        price: String,
        pricePerToken: String
      }
    },
    liquidity_distribution: {
      effective_liquidity_ratio: Number,
      distribution_type: String
    },
    fee_info: {
      base_fee: String,
      max_fee: String,
      current_dynamic_fee: String
    },
    stability_metrics: {
      price_volatility: Number,
      yield_stability: Number,
      stability_score: Number
    },
    risk_metrics: {
      price_risk: Number,
      liquidity_risk: Number,
      overall_risk: Number
    },
    scores: {
      base_performance_score: Number,
      liquidity_distribution_score: Number,
      fee_efficiency_score: Number,
      stability_score: Number,
      risk_score: Number,
      final_score: Number
    },
    recommendation: {
      position_size: String,
      price_range: {
        min: Number,
        max: Number,
        current: Number,
        optimal_range_percentage: Number
      },
      bin_distribution: String,
      bin_step: Number
    },
    tier: String
  }],
  t2_pools: [{
    // 与 t1_pools 相同的结构
  }],
  t3_pools: [{
    // 与 t1_pools 相同的结构
  }],
  createdAt: Date,
  updatedAt: Date
}, {
  timestamps: true
});

const Signal = mongoose.model('Signal', signalSchema);

// 健康检查路由
app.get('/health', async (req, res) => {
  try {
    // 检查 MongoDB 连接
    if (mongoose.connection.readyState !== 1) {
      return res.status(503).json({
        status: 'error',
        message: 'MongoDB 连接不可用'
      });
    }

    res.status(200).json({
      status: 'ok',
      service: 'signal-service',
      timestamp: new Date().toISOString(),
      connections: {
        mongodb: 'connected'
      }
    });
  } catch (error) {
    console.error('健康检查失败:', error);
    res.status(500).json({
      status: 'error',
      message: '健康检查失败'
    });
  }
});

// API 路由
app.get('/api/signals', async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;
    
    // 从数据库获取信号数据
    const signals = await Signal.find()
      .sort({ analysis_timestamp: -1 })
      .skip(Number(offset))
      .limit(Number(limit));
    
    // 获取总数
    const total = await Signal.countDocuments();
    
    res.status(200).json({
      signals,
      pagination: {
        total,
        limit: Number(limit),
        offset: Number(offset)
      }
    });
  } catch (error) {
    console.error('获取信号失败:', error);
    res.status(500).json({ error: '获取信号失败' });
  }
});

app.get('/api/signals/:id', async (req, res) => {
  try {
    const signal = await Signal.findOne({ id: req.params.id });
    
    if (!signal) {
      return res.status(404).json({ error: '信号未找到' });
    }
    
    res.status(200).json(signal);
  } catch (error) {
    console.error('获取信号失败:', error);
    res.status(500).json({ error: '获取信号失败' });
  }
});

// 添加一个测试路由，用于发布测试信号
app.post('/api/test/publish-signal', async (req, res) => {
  try {
    const testSignal = {
      id: uuidv4(),
      timestamp: new Date().toISOString(),
      poolId: 'test-pool',
      tokenA: 'SOL',
      tokenB: 'USDC',
      action: 'BUY',
      confidence: 0.8,
      price: 100.0,
      reason: '测试信号',
      metadata: {
        test: true
      }
    };
    
    // 存储信号
    signals.set(testSignal.id, testSignal);
    
    // 发布信号到队列并存储到数据库
    const result = await publishSignal(testSignal);
    if (result) {
      res.status(200).json({ success: true, message: '测试信号已发布并存储到数据库', signal: testSignal });
    } else {
      res.status(500).json({ success: false, message: '发布信号失败' });
    }
  } catch (error) {
    console.error('发布测试信号失败:', error);
    res.status(500).json({ error: '发布测试信号失败' });
  }
});

// 清理过期信号
const cleanupExpiredSignals = () => {
  const now = new Date();
  let cleanupCount = 0;
  
  signals.forEach((signal, id) => {
    const signalDate = new Date(signal.timestamp);
    const ageInHours = (now.getTime() - signalDate.getTime()) / (1000 * 60 * 60);
    
    // 删除超过24小时的信号
    if (ageInHours > 24) {
      signals.delete(id);
      cleanupCount++;
    }
  });
  
  if (cleanupCount > 0) {
    console.log(`已清理 ${cleanupCount} 个过期信号`);
  }
};

// 设置定期清理过期信号的间隔
const cleanupInterval = setInterval(cleanupExpiredSignals, 3600000); // 每小时清理一次

// 发布信号到队列并存储到数据库
const publishSignal = async (signal) => {
  try {
    // 将信号发布到 RabbitMQ 队列
    if (channel) {
      try {
        await channel.publish('', SIGNAL_QUEUE, Buffer.from(JSON.stringify(signal)), {
          persistent: true
        });
        console.log(`信号已发布到队列: ${signal.id}`);
      } catch (error) {
        console.error('发布信号到 RabbitMQ 失败:', error);
      }
    }
    
    // 将信号存储到 MongoDB
    const newSignal = new Signal({
      id: signal.id,
      analysis_timestamp: new Date(),
      market_condition: {
        trend: 'neutral',
        volatility: 'medium'
      },
      t1_pools: [{
        pool_address: signal.poolId,
        name: `${signal.tokenA}-${signal.tokenB}`,
        token_pair: {
          token_x: {
            symbol: signal.tokenA,
            address: '0x...'
          },
          token_y: {
            symbol: signal.tokenB,
            address: '0x...'
          }
        },
        metrics: {
          liquidity: 1000000,
          volume_24h: 500000,
          fees_24h: 1500,
          daily_yield: 0.05,
          active_bin: {
            binId: 100,
            price: signal.price ? signal.price.toString() : '0',
            pricePerToken: signal.price ? (signal.price * 0.99).toString() : '0'
          }
        },
        liquidity_distribution: {
          effective_liquidity_ratio: 0.85,
          distribution_type: 'balanced'
        },
        fee_info: {
          base_fee: '0.01%',
          max_fee: '0.05%',
          current_dynamic_fee: '0.02%'
        },
        stability_metrics: {
          price_volatility: 0.2,
          yield_stability: 0.8,
          stability_score: 0.7
        },
        risk_metrics: {
          price_risk: 0.3,
          liquidity_risk: 0.2,
          overall_risk: 0.25
        },
        scores: {
          base_performance_score: 0.8,
          liquidity_distribution_score: 0.75,
          fee_efficiency_score: 0.85,
          stability_score: 0.7,
          risk_score: 0.75,
          final_score: 0.78
        },
        recommendation: {
          position_size: 'medium',
          price_range: {
            min: signal.price ? Number((signal.price * 0.95).toFixed(8)) : 95,
            max: signal.price ? Number((signal.price * 1.05).toFixed(8)) : 105,
            current: signal.price ? Number(signal.price.toFixed(8)) : 100,
            optimal_range_percentage: 5
          },
          bin_distribution: 'normal',
          bin_step: 10
        },
        tier: 'T1'
      }]
    });
    
    await newSignal.save();
    console.log(`信号已存储到数据库: ${signal.id}`);
    
    return true;
  } catch (error) {
    console.error('发布信号失败:', error);
    return false;
  }
};

// 设置 RabbitMQ 连接
const setupRabbitMQ = async () => {
  try {
    // 创建连接
    connection = await amqp.connect(connectionURL);
    console.log('RabbitMQ 连接成功');
    
    // 创建通道
    channel = await connection.createChannel();
    console.log('RabbitMQ 通道创建成功');
    
    // 确保队列存在
    await channel.assertQueue(SIGNAL_QUEUE, { durable: true });
    console.log(`队列已确认: ${SIGNAL_QUEUE}`);
    
    // 确保池数据队列存在
    await channel.assertQueue(POOL_DATA_QUEUE, { durable: true });
    console.log(`队列已确认: ${POOL_DATA_QUEUE}`);
    
    // 设置池数据队列的消费者
    await channel.consume(POOL_DATA_QUEUE, async (msg) => {
      if (msg) {
        try {
          const poolData = JSON.parse(msg.content.toString());
          console.log('收到池数据，开始处理...');
          await processPoolData(poolData);
          channel.ack(msg);
        } catch (error) {
          console.error('处理池数据失败:', error);
          channel.nack(msg, false, true);
        }
      }
    }, { noAck: false });
    console.log(`已设置 ${POOL_DATA_QUEUE} 的消费者`);
    
    return true;
  } catch (error) {
    console.error('RabbitMQ 设置失败:', error);
    return false;
  }
};

// 启动服务器
const startServer = async () => {
  try {
    console.log('信号服务启动中...');
    console.log(`环境变量: PORT=${PORT}, RABBITMQ_HOST=${RABBITMQ_HOST}, RABBITMQ_USER=${RABBITMQ_USER}, MONGODB_URI=${MONGODB_URI}`);
    
    // 连接到MongoDB
    await mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB连接成功');
    
    // 设置 RabbitMQ
    const rabbitConnected = await setupRabbitMQ();
    if (!rabbitConnected) {
      console.warn('RabbitMQ 连接失败，但服务将继续运行');
    }
    
    // 启动 HTTP 服务器
    app.listen(PORT, () => {
      console.log(`信号服务已启动，监听端口 ${PORT}`);
    });
    
    console.log('信号服务已启动');
  } catch (error) {
    console.error('服务器启动失败:', error);
    process.exit(1);
  }
};

// 处理进程终止信号
process.on('SIGINT', async () => {
  console.log('接收到 SIGINT 信号，正在关闭服务...');
  clearInterval(cleanupInterval);
  
  // 关闭MongoDB连接
  try {
    await mongoose.connection.close();
    console.log('MongoDB连接已关闭');
  } catch (error) {
    console.error('关闭MongoDB连接时出错:', error);
  }
  
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('接收到 SIGTERM 信号，正在关闭服务...');
  clearInterval(cleanupInterval);
  
  // 关闭MongoDB连接
  try {
    await mongoose.connection.close();
    console.log('MongoDB连接已关闭');
  } catch (error) {
    console.error('关闭MongoDB连接时出错:', error);
  }
  
  process.exit(0);
});

/**
 * 处理池数据并生成信号
 */
const processPoolData = async (poolData) => {
  try {
    // 检查消息格式
    let pools = [];
    if (poolData.type === 'pool_data' && Array.isArray(poolData.data)) {
      pools = poolData.data;
    } else if (poolData.type === 'pool_data' && poolData.data) {
      pools = [poolData.data];
    } else if (Array.isArray(poolData)) {
      pools = poolData;
    } else if (poolData.id || poolData.address) {
      pools = [poolData];
    } else {
      console.error('无效的池数据格式');
      return;
    }

    console.log(`收到 ${pools.length} 个池数据`);

    // 过滤掉无效的池数据
    pools = pools.filter(pool => {
      if (!pool.address || !pool.liquidity || !pool.volume24h) {
        console.log(`跳过无效池数据: ${pool.id || pool.address || 'unknown'}`);
        return false;
      }
      return true;
    });

    // 限制处理前100个池子
    if (pools.length > 100) {
      console.log(`限制处理前100个池子,原始数量: ${pools.length}`);
      pools = pools.slice(0, 100);
    }

    // 生成分级信号
    await generateTieredSignals(pools);
  } catch (error) {
    console.error('处理池数据失败:', error);
  }
};

/**
 * 计算基础性能评分
 */
const calculateBasePerformanceScore = (pool) => {
  try {
    // 流动性评分 (0-100)
    const liquidityScore = Math.min(100, (pool.liquidity || 0) / 100000);
    
    // 交易量评分 (0-100)
    const volumeScore = Math.min(100, (pool.volume24h || 0) / 50000);
    
    // 费用评分 (0-100)
    const feeScore = Math.min(100, (pool.fees24h || 0) / 500);
    
    // 收益率评分 (0-100)
    const yieldScore = Math.min(100, ((pool.yield24h || 0) * 100) * 10);
    
    // 计算最终性能评分 (加权平均)
    const finalScore = (
      liquidityScore * 0.3 + 
      volumeScore * 0.3 + 
      feeScore * 0.2 + 
      yieldScore * 0.2
    );
    
    return {
      liquidityScore,
      volumeScore,
      feeScore,
      yieldScore,
      finalScore
    };
  } catch (error) {
    console.error('计算基础性能评分失败:', error);
    return {
      liquidityScore: 0,
      volumeScore: 0,
      feeScore: 0,
      yieldScore: 0,
      finalScore: 0
    };
  }
};

/**
 * 计算稳定性评分
 */
const calculateStabilityScore = (pool) => {
  try {
    // 价格波动性 (0-100，越低越好)
    const priceVolatility = Math.min(100, Math.abs((pool.priceChange24h || 0) * 100) * 2);
    
    // 收益率稳定性 (0-100，越高越好)
    const yieldStability = Math.min(100, 100 - Math.abs((pool.yieldChange24h || 0) * 100));
    
    // 计算最终稳定性评分 (加权平均)
    const stabilityScore = (
      (100 - priceVolatility) * 0.6 + 
      yieldStability * 0.4
    );
    
    return {
      priceVolatility,
      yieldStability,
      stabilityScore
    };
  } catch (error) {
    console.error('计算稳定性评分失败:', error);
    return {
      priceVolatility: 50,
      yieldStability: 50,
      stabilityScore: 50
    };
  }
};

/**
 * 计算风险评分
 */
const calculateRiskScore = (pool) => {
  try {
    // 价格风险 (0-100，越高风险越大)
    const priceRisk = Math.min(100, Math.abs((pool.priceChange24h || 0) * 100) * 3);
    
    // 流动性风险 (0-100，越高风险越大)
    const liquidityRisk = Math.min(100, 100 - Math.min(100, (pool.liquidity || 0) / 50000));
    
    // 计算最终风险评分 (加权平均)
    const finalRiskScore = (
      priceRisk * 0.6 + 
      liquidityRisk * 0.4
    );
    
    return {
      priceRisk,
      liquidityRisk,
      finalRiskScore
    };
  } catch (error) {
    console.error('计算风险评分失败:', error);
    return {
      priceRisk: 50,
      liquidityRisk: 50,
      finalRiskScore: 50
    };
  }
};

/**
 * 生成分级信号（T1、T2、T3）
 */
const generateTieredSignals = async (poolsData) => {
  try {
    console.log(`开始为 ${poolsData.length} 个池生成分级信号`);
    
    // 计算每个池的评分
    const poolsWithScores = [];
    
    for (const pool of poolsData) {
      try {
        const poolId = pool.address;
        const tokenA = pool.tokenA || pool.tokenX || 'Unknown';
        const tokenB = pool.tokenB || pool.tokenY || 'Unknown';
        
        console.log(`计算池 ${poolId} (${tokenA}/${tokenB}) 的评分`);
        
        // 计算性能评分 (40%)
        const performanceScore = calculateBasePerformanceScore(pool);
        
        // 计算稳定性评分 (40%)
        const stabilityScore = calculateStabilityScore(pool);
        
        // 计算风险评分 (20%)
        const riskScore = calculateRiskScore(pool);
        
        // 计算最终评分
        const finalScore = (
          performanceScore.finalScore * 0.4 + 
          stabilityScore.stabilityScore * 0.4 + 
          (100 - riskScore.finalRiskScore) * 0.2
        );
        
        // 添加到池数组
        poolsWithScores.push({
          pool,
          poolId,
          tokenA,
          tokenB,
          performanceScore,
          stabilityScore,
          riskScore,
          finalScore
        });

        console.log(`池 ${poolId} 评分计算完成:`, {
          performance: performanceScore.finalScore.toFixed(2),
          stability: stabilityScore.stabilityScore.toFixed(2),
          risk: riskScore.finalRiskScore.toFixed(2),
          final: finalScore.toFixed(2)
        });
      } catch (error) {
        console.error(`计算池 ${pool.address} 评分失败:`, error);
      }
    }
    
    // 按最终评分排序
    poolsWithScores.sort((a, b) => b.finalScore - a.finalScore);
    
    console.log(`已计算 ${poolsWithScores.length} 个池的评分并排序`);
    
    // 选择T1、T2、T3池子
    const t1Count = Math.min(3, poolsWithScores.length);
    const t2Count = Math.min(5, poolsWithScores.length - t1Count);
    const t3Count = Math.min(7, poolsWithScores.length - t1Count - t2Count);
    
    const t1Pools = poolsWithScores.slice(0, t1Count);
    const t2Pools = poolsWithScores.slice(t1Count, t1Count + t2Count);
    const t3Pools = poolsWithScores.slice(t1Count + t2Count, t1Count + t2Count + t3Count);
    
    console.log(`已选择:
      T1池子: ${t1Pools.length} 个 (评分阈值: ${t1Pools[t1Pools.length-1]?.finalScore.toFixed(2) || 0})
      T2池子: ${t2Pools.length} 个 (评分阈值: ${t2Pools[t2Pools.length-1]?.finalScore.toFixed(2) || 0})
      T3池子: ${t3Pools.length} 个 (评分阈值: ${t3Pools[t3Pools.length-1]?.finalScore.toFixed(2) || 0})`
    );
    
    // 创建信号对象
    const signalId = uuidv4();
    const signal = createTieredSignal(t1Pools, t2Pools, t3Pools);
    
    // 设置信号ID
    signal.id = signalId;
    
    // 存储信号到内存和MongoDB
    signals.set(signalId, signal);
    
    try {
      // 保存到MongoDB
      const signalDoc = new Signal(signal);
      await signalDoc.save();
      console.log(`信号已保存到MongoDB: ${signalId}`);
    } catch (error) {
      console.error('保存信号到MongoDB失败:', error);
    }
    
    // 发布信号到队列
    await publishSignal(signal);
    
    console.log(`分级信号已生成并发布: ${signalId}`);
    
    return signal;
  } catch (error) {
    console.error('生成分级信号失败:', error);
    throw error;
  }
};

/**
 * 创建分级信号对象
 */
const createTieredSignal = (t1Pools, t2Pools, t3Pools) => {
  // 确定市场状况
  const marketCondition = determineMarketCondition(t1Pools);
  
  // 创建信号对象
  return {
    analysis_timestamp: new Date().toISOString(),
    market_condition: marketCondition,
    t1_pools: t1Pools.map(poolData => formatPoolData(poolData, 'T1')),
    t2_pools: t2Pools.map(poolData => formatPoolData(poolData, 'T2')),
    t3_pools: t3Pools.map(poolData => formatPoolData(poolData, 'T3'))
  };
};

/**
 * 确定市场状况
 */
const determineMarketCondition = (topPools) => {
  // 分析顶级池子的价格变化来确定趋势
  let priceChangeSum = 0;
  let volatilitySum = 0;
  let count = 0;
  
  for (const poolData of topPools) {
    const pool = poolData.pool;
    if (pool.priceChange24h) {
      priceChangeSum += pool.priceChange24h;
      volatilitySum += Math.abs(pool.priceChange24h);
      count++;
    }
  }
  
  // 确定趋势
  let trend = 'neutral';
  if (count > 0) {
    const avgPriceChange = priceChangeSum / count;
    if (avgPriceChange > 0.03) trend = 'upward';
    else if (avgPriceChange < -0.03) trend = 'downward';
  }
  
  // 确定波动性
  let volatility = 'low';
  if (count > 0) {
    const avgVolatility = volatilitySum / count;
    if (avgVolatility > 0.1) volatility = 'high';
    else if (avgVolatility > 0.05) volatility = 'medium';
  }
  
  return {
    trend,
    volatility
  };
};

/**
 * 格式化池数据
 */
const formatPoolData = (poolData, tier) => {
  const pool = poolData.pool;
  // 确保currentPrice是有效的数字，默认为1
  const currentPrice = (pool.currentPrice && !isNaN(pool.currentPrice)) ? pool.currentPrice : 1;
  
  // 根据评分和层级确定仓位大小
  let positionSize;
  if (tier === 'T1') {
    positionSize = poolData.finalScore >= 90 ? 'large' : 'medium';
  } else if (tier === 'T2') {
    positionSize = 'medium';
  } else {
    positionSize = 'small';
  }
  
  // 根据波动性确定价格范围
  const volatility = Math.abs(pool.priceChange24h || 0);
  let priceRangePercentage;
  if (volatility > 0.1) {
    priceRangePercentage = 0.2; // 高波动性,更宽的范围
  } else if (volatility > 0.05) {
    priceRangePercentage = 0.1; // 中等波动性
  } else {
    priceRangePercentage = 0.05; // 低波动性
  }
  
  // 根据流动性分布确定分布类型
  let distributionType = 'balanced';
  if (pool.liquidityConcentration > 0.8) {
    distributionType = 'concentrated';
  } else if (pool.liquidityConcentration < 0.3) {
    distributionType = 'distributed';
  }
  
  // 确保价格范围的计算结果是有效的数字
  let minPrice = currentPrice * (1 - priceRangePercentage);
  let maxPrice = currentPrice * (1 + priceRangePercentage);
  
  // 确保minPrice和maxPrice是有效的数字
  if (isNaN(minPrice) || !isFinite(minPrice)) minPrice = currentPrice * 0.95;
  if (isNaN(maxPrice) || !isFinite(maxPrice)) maxPrice = currentPrice * 1.05;
  
  return {
    pool_address: pool.address,
    name: `${poolData.tokenA}/${poolData.tokenB}`,
    token_pair: {
      token_x: {
        symbol: poolData.tokenA,
        address: pool.tokenXAddress || 'unknown'
      },
      token_y: {
        symbol: poolData.tokenB,
        address: pool.tokenYAddress || 'unknown'
      }
    },
    metrics: {
      liquidity: pool.liquidity || 0,
      volume_24h: pool.volume24h || 0,
      fees_24h: pool.fees24h || 0,
      daily_yield: pool.yield24h || 0,
      active_bin: {
        binId: pool.activeBin?.id || 0,
        price: (pool.activeBin?.price !== undefined && !isNaN(pool.activeBin?.price)) ? pool.activeBin.price.toString() : currentPrice.toString(),
        pricePerToken: (pool.activeBin?.pricePerToken !== undefined && !isNaN(pool.activeBin?.pricePerToken)) ? pool.activeBin.pricePerToken.toString() : currentPrice.toString()
      }
    },
    liquidity_distribution: {
      effective_liquidity_ratio: pool.effectiveLiquidity || 0.8,
      distribution_type: distributionType
    },
    fee_info: {
      base_fee: pool.baseFee?.toString() || "0",
      max_fee: pool.maxFee?.toString() || "0",
      current_dynamic_fee: pool.currentFee?.toString() || "0"
    },
    stability_metrics: {
      price_volatility: poolData.stabilityScore.priceVolatility || 0,
      yield_stability: poolData.stabilityScore.yieldStability || 0,
      stability_score: poolData.stabilityScore.stabilityScore || 0
    },
    risk_metrics: {
      price_risk: poolData.riskScore.priceRisk || 0,
      liquidity_risk: poolData.riskScore.liquidityRisk || 0,
      overall_risk: poolData.riskScore.finalRiskScore || 0
    },
    scores: {
      base_performance_score: poolData.performanceScore.finalScore || 0,
      liquidity_distribution_score: poolData.performanceScore.liquidityScore || 0,
      fee_efficiency_score: poolData.performanceScore.feeScore || 0,
      stability_score: poolData.stabilityScore.stabilityScore || 0,
      risk_score: poolData.riskScore.finalRiskScore || 0,
      final_score: poolData.finalScore || 0
    },
    recommendation: {
      position_size: positionSize,
      price_range: {
        min: Number(minPrice.toFixed(8)),
        max: Number(maxPrice.toFixed(8)),
        current: Number(currentPrice.toFixed(8)),
        optimal_range_percentage: Number((priceRangePercentage * 100).toFixed(2))
      },
      bin_distribution: distributionType,
      bin_step: pool.binStep || 50
    },
    tier: tier
  };
};

// 启动服务器
startServer(); 